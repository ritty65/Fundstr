<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Nostr User Search & Featured Creators</title>
    <link rel="preload" as="style" href="find-creators.css" />
    <link rel="stylesheet" href="find-creators.css" />
    <!-- nostr-tools CDN -->
    <script src="https://unpkg.com/nostr-tools@1.17.0/lib/nostr.bundle.js"></script>
    <script type="application/json" id="fundstr-relay-config">
      {
        "primary": "wss://relay.fundstr.me",
        "paid": ["wss://relay.primal.net"]
      }
    </script>
    <style>
      body {
        font-family: "Inter", sans-serif;
        background-color: #f7fafc; /* Tailwind gray-100 */
        color: #2d3748; /* Tailwind gray-800 */
      }
      .container {
        width: 100%;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: clamp(2rem, 4vw, 3rem);
        padding: clamp(1.5rem, 4vw, 3rem) clamp(1rem, 4vw, 2.5rem);
        box-sizing: border-box;
      }
      .search-container,
      .featured-creators-container {
        width: min(100%, clamp(320px, 85vw, 1100px));
        margin: 0 auto;
        padding: clamp(1.5rem, 4vw, 2.5rem);
        background-color: white;
        border-radius: 0.75rem; /* Tailwind rounded-xl */
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1),
          0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Tailwind shadow-lg */
      }
      .search-input {
        width: 100%;
        padding: 0.875rem 1.25rem; /* Increased padding */
        border: 1px solid #e2e8f0; /* Tailwind gray-300 */
        border-radius: 0.5rem; /* Tailwind rounded-lg */
        font-size: 1rem;
        transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        color: #2d3748; /* Tailwind gray-800 */
      }
      .search-input:focus {
        outline: none;
        border-color: #4299e1; /* Tailwind blue-500 */
        box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5); /* Tailwind ring-blue-500 ring-opacity-50 */
      }
      .results-list,
      .featured-creators-grid {
        margin-top: 1.5rem;
        list-style: none;
        padding: 0;
      }
      .featured-creators-grid {
        display: grid;
        grid-template-columns: repeat(
          auto-fill,
          minmax(280px, 1fr)
        ); /* Responsive grid */
        gap: 1.5rem;
      }
      .result-item,
      .creator-card {
        padding: 1.25rem;
        border: 1px solid #e2e8f0; /* Tailwind gray-300 */
        border-radius: 0.75rem; /* Tailwind rounded-xl */
        margin-bottom: 1rem;
        background-color: #fdfdff; /* Slightly off-white */
        transition: all 0.2s ease-in-out;
        display: flex;
        flex-direction: column; /* Ensure actions container is below info */
        gap: 0.5rem; /* Reduced gap for tighter layout within card */
      }
      .creator-card {
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.07),
          0 2px 4px -1px rgba(0, 0, 0, 0.04);
        position: relative;
      }
      .result-item {
        position: relative;
      }
      .result-item:hover,
      .creator-card:hover {
        background-color: #f0f5ff; /* Lighter blue hover */
        border-color: #bee3f8; /* Tailwind blue-200 */
        transform: translateY(-2px);
        box-shadow: 0 8px 25px -5px rgba(0, 0, 0, 0.1),
          0 10px 10px -5px rgba(0, 0, 0, 0.04);
      }
      .profile-header {
        display: flex;
        align-items: flex-start;
        gap: 1rem;
        width: 100%;
      }
      .profile-header img.avatar {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        object-fit: cover;
        border: 2px solid #e2e8f0; /* Tailwind gray-300 */
        flex-shrink: 0;
      }
      .profile-header .info {
        flex-grow: 1;
        min-width: 0;
      }
      .profile-header .info h3 {
        font-size: 1.125rem; /* Tailwind text-lg */
        font-weight: 600; /* Tailwind font-semibold */
        color: #2d3748; /* Tailwind gray-800 */
        word-break: break-word;
        margin-bottom: 0.25rem;
      }
      .profile-header .info p {
        font-size: 0.875rem; /* Tailwind text-sm */
        color: #4a5568; /* Tailwind gray-700 */
        margin-top: 0.1rem;
        word-break: break-word;
        line-height: 1.4;
      }
      .profile-header .info .nip05 {
        font-weight: 500;
        color: #3182ce; /* Tailwind blue-600 */
      }
      .creator-actions {
        opacity: 0;
        transition: opacity 0.3s ease-in-out;
        padding-top: 0.5rem;
        display: flex;
        gap: 0.5rem;
        width: 100%;
        justify-content: flex-start;
      }
      .creator-card:hover .creator-actions,
      .result-item:hover .creator-actions {
        opacity: 1;
      }
      .action-button {
        padding: 0.375rem 0.75rem;
        font-size: 0.75rem;
        font-weight: 600;
        border-radius: 0.375rem;
        color: white;
        transition: background-color 0.2s;
        box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
      }
      .view-button {
        background-color: #a0aec0;
      }
      .view-button:hover {
        background-color: #718096;
      }
      .message-button {
        background-color: #4299e1;
      }
      .message-button:hover {
        background-color: #3182ce;
      }
      .donate-button {
        background-color: #48bb78;
      }
      .donate-button:hover {
        background-color: #38a169;
      }
      .status-message {
        text-align: center;
        color: #718096;
        padding: 1.5rem;
        font-style: italic;
      }
      .relay-warning {
        margin-top: 1rem;
        padding: 0.75rem 1rem;
        background-color: #fef3c7;
        border: 1px solid #f6ad55;
        border-radius: 0.5rem;
        color: #b7791f;
        font-weight: 600;
      }
      .relay-log {
        margin: 0.75rem auto 0;
        padding: 0.75rem 1rem;
        background-color: #f8fafc;
        border: 1px solid #e2e8f0;
        border-radius: 0.5rem;
        color: #4a5568;
        font-size: 0.875rem;
        list-style: none;
        width: min(100%, clamp(320px, 85vw, 1100px));
      }
      .relay-log.hidden {
        display: none;
      }
      .relay-log li + li {
        margin-top: 0.5rem;
      }
      .retry-button {
        margin: 0 auto;
        margin-top: -1rem;
        padding: 0.5rem 1rem;
        font-size: 0.875rem;
        font-weight: 600;
        color: white;
        background-color: #4299e1;
        border-radius: 0.375rem;
        transition: background-color 0.2s;
        display: block;
      }
      .retry-button:hover {
        background-color: #3182ce;
      }
      .loader {
        display: none;
        margin: 1.5rem auto;
        border: 4px solid #e2e8f0;
        border-top: 4px solid #4299e1;
        border-radius: 50%;
        width: 36px;
        height: 36px;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      .relay-info {
        font-size: 0.8rem;
        color: #718096;
        text-align: center;
        margin-top: 1.5rem;
        padding: 0.75rem;
        background-color: #edf2f7;
        border-radius: 0.5rem;
      }
      .copy-button {
        background-color: #edf2f7;
        color: #4a5568;
        padding: 0.25rem 0.6rem;
        font-size: 0.75rem;
        border-radius: 0.375rem;
        cursor: pointer;
        margin-left: 0.5rem;
        border: 1px solid #cbd5e0;
        transition: background-color 0.2s;
      }
      .copy-button:hover {
        background-color: #e2e8f0;
      }
      .section-title {
        font-size: 1.5rem;
        font-weight: 700;
        color: #2d3748;
        margin-bottom: 1.5rem;
        text-align: center;
        padding-bottom: 0.5rem;
        border-bottom: 2px solid #e2e8f0;
      }
      body.dark .section-title {
        color: #e2e8f0;
        border-bottom-color: #4a5568;
      }
      body.dark {
        background-color: #1a202c;
        color: #e2e8f0;
      }
      body.dark .search-container,
      body.dark .featured-creators-container {
        background-color: #2d3748;
        color: #e2e8f0;
      }
      body.dark .search-input {
        background-color: #2d3748;
        border-color: #4a5568;
        color: #e2e8f0;
      }
      body.dark .result-item,
      body.dark .creator-card {
        background-color: #2d3748;
        border-color: #4a5568;
      }
      body.dark .result-item:hover,
      body.dark .creator-card:hover {
        background-color: #4a5568;
        border-color: #718096;
      }
      body.dark .profile-header .info h3 {
        color: #e2e8f0;
      }
      body.dark .profile-header .info p {
        color: #a0aec0;
      }
      body.dark .profile-header .info .nip05 {
        color: #63b3ed;
      }
    </style>
  </head>
  <body class="bg-gray-100">
    <div class="container">
      <div class="search-container">
        <h1 class="section-title">Nostr User Search</h1>
        <p class="text-sm text-center text-gray-600 mb-6">
          Search by name, npub, or NIP-05 identifier (e.g., user@domain.com).
        </p>
        <input
          type="text"
          id="searchInput"
          class="search-input"
          placeholder="Search Nostr profiles..."
        />
        <div id="loader" class="loader"></div>
        <ul id="resultsList" class="results-list"></ul>
        <p id="statusMessage" class="status-message hidden"></p>
        <button id="retryButton" class="retry-button hidden" type="button">
          Retry
        </button>
      </div>

      <div class="featured-creators-container">
        <h2 class="section-title">Featured Creators</h2>
        <div
          id="featuredCreatorsLoader"
          class="loader"
          style="display: block"
        ></div>
        <div id="featuredCreatorsGrid" class="featured-creators-grid"></div>
        <p id="featuredStatusMessage" class="status-message hidden"></p>
      </div>

      <p id="relayWarning" class="relay-warning hidden"></p>
      <ul id="relayDiagnostics" class="relay-log hidden"></ul>
      <div class="relay-info">Connecting to: <span id="relayList"></span></div>
    </div>

    <script type="module" defer>
      import {
        describeRelay,
        formatRelayList,
        getDefaultRelayList,
        getRelayConfig,
      } from "./relayConfig.js";
      import {
        filterHealthyRelays,
        getRelayDiagnosticsSnapshot,
        pingRelay,
      } from "./relayHealth.js";
      import { createExponentialBackoffScheduler } from "./retryScheduler.js";

      const relayConfig = getRelayConfig();
      const FUNDSTR_RELAY = relayConfig.primary;
      const curatedBackups = relayConfig.backups;
      const paidBackups = relayConfig.paid;
      const DEFAULT_RELAYS = getDefaultRelayList();
      const primaryRelayHost = describeRelay(FUNDSTR_RELAY);
      const primaryRelayLabel = `${primaryRelayHost} relay`;
      const statusMessageElement = document.getElementById("statusMessage");
      const relayWarningElement = document.getElementById("relayWarning");
      const relayDiagnosticsElement = document.getElementById(
        "relayDiagnostics",
      );
      const retryButtonElement = document.getElementById("retryButton");
      const relayListElement = document.getElementById("relayList");
      // --- Nostr Tools ---
      if (!window.NostrTools) {
        statusMessageElement.textContent =
          "Error: nostr-tools library not loaded.";
        statusMessageElement.classList.remove("hidden");
      }
      const { SimplePool, nip19, utils } = window.NostrTools;

      document.body.classList.toggle(
        "dark",
        window.matchMedia &&
          window.matchMedia("(prefers-color-scheme: dark)").matches,
      );

      let RELAYS = [...DEFAULT_RELAYS];

      const paidBackupHosts = paidBackups.filter(
        (url) => !curatedBackups.includes(url),
      );

      function renderRelayList(relays) {
        const [primary, ...activeBackups] = relays;
        const parts = [`Primary: ${describeRelay(primary)}`];
        if (activeBackups.length) {
          parts.push(`Active backups: ${formatRelayList(activeBackups)}`);
        } else if (curatedBackups.length) {
          parts.push(
            `Backups on deck: ${formatRelayList(curatedBackups)}`,
          );
        } else {
          parts.push("Backups: none configured");
        }
        if (paidBackupHosts.length) {
          parts.push(
            `Opt-in paid backups: ${formatRelayList(paidBackupHosts)}`,
          );
        }
        relayListElement.textContent = parts.join(" • ");
      }

      renderRelayList(RELAYS);

      const pool = new SimplePool({ eoseSubTimeout: 8000 });
      let currentSearchAbortController = null;
      let lastSearchQuery = "";
      let currentSearchProfiles = new Map();
      let hasInitialRender = false;
      let viewProfileNotified = false;

      const EMPTY_RESULT_CODE = "EMPTY_RESULT";

      const monitoredRelaySet = new Set([
        ...DEFAULT_RELAYS,
        ...curatedBackups,
        ...paidBackups,
        FUNDSTR_RELAY,
      ]);

      function getMonitoredDiagnostics() {
        const snapshot = getRelayDiagnosticsSnapshot();
        return snapshot
          .filter((entry) => monitoredRelaySet.has(entry.url))
          .sort((a, b) => {
            if (a.url === b.url) return 0;
            if (a.url === FUNDSTR_RELAY) return -1;
            if (b.url === FUNDSTR_RELAY) return 1;
            return a.url.localeCompare(b.url);
          });
      }

      function describeDiagnostic(entry) {
        const host = describeRelay(entry.url);
        if (entry.status === "ok") {
          return `${host}: reachable`;
        }
        const typeLabel = (entry.type || entry.status || "error").replace(
          /-/g,
          " ",
        );
        const codeLabel = entry.code ? ` (code: ${entry.code})` : "";
        const messageText = entry.message
          ? ` — ${entry.message}`
          : entry.softFailure
          ? " — relay restricted this origin"
          : "";
        return `${host}: ${typeLabel}${codeLabel}${messageText}`;
      }

      function renderRelayDiagnostics(diagnostics) {
        if (!relayDiagnosticsElement) return;
        relayDiagnosticsElement.innerHTML = "";
        if (!diagnostics.length) {
          relayDiagnosticsElement.classList.add("hidden");
          return;
        }
        diagnostics.forEach((entry) => {
          const li = document.createElement("li");
          li.textContent = describeDiagnostic(entry);
          relayDiagnosticsElement.appendChild(li);
        });
        relayDiagnosticsElement.classList.remove("hidden");
      }

      function summarizeProbe(result) {
        if (!result || result.ok) {
          return "reachable";
        }
        if (result.error?.type === "restricted-origin" || result.softFailure) {
          return "origin restricted";
        }
        const typeLabel = (result.error?.type || "error").replace(/-/g, " ");
        const codeLabel = result.error?.code ? ` (code: ${result.error.code})` : "";
        return `${typeLabel}${codeLabel}`;
      }

      function computeFallbackDescriptor(activeBackups) {
        if (activeBackups.length) return formatRelayList(activeBackups);
        if (curatedBackups.length) return formatRelayList(curatedBackups);
        if (paidBackupHosts.length)
          return `opt-in paid relays (${formatRelayList(paidBackupHosts)})`;
        return "no backups available";
      }

      function describeLastError(diagnostics) {
        if (!diagnostics.length) return "unknown error";
        const [first] = diagnostics;
        const host = describeRelay(first.url);
        const typeLabel = (first.type || first.status || "error").replace(
          /-/g,
          " ",
        );
        const codeLabel = first.code ? ` (code: ${first.code})` : "";
        return `${host} → ${typeLabel}${codeLabel}`;
      }

      async function refreshRelays() {
        const healthy = await filterHealthyRelays(DEFAULT_RELAYS);
        const fundstrProbe = await pingRelay(FUNDSTR_RELAY);
        const prioritized = [
          FUNDSTR_RELAY,
          ...healthy.filter((relay) => relay !== FUNDSTR_RELAY),
        ];
        RELAYS = Array.from(new Set(prioritized));
        renderRelayList(RELAYS);

        const diagnostics = getMonitoredDiagnostics();
        const failingDiagnostics = diagnostics.filter(
          (entry) => entry.status === "error",
        );

        if (fundstrProbe.ok) {
          relayWarningElement.classList.add("hidden");
          relayWarningElement.textContent = "";
          renderRelayDiagnostics([]);
        } else {
          const activeBackups = RELAYS.slice(1);
          const fallbackDescriptor = computeFallbackDescriptor(activeBackups);
          const probeSummary = summarizeProbe(fundstrProbe);
          relayWarningElement.textContent =
            fallbackDescriptor === "no backups available"
              ? `${primaryRelayLabel} is temporarily unreachable (${probeSummary}) and no backups are configured yet.`
              : `${primaryRelayLabel} is temporarily unreachable (${probeSummary}). We'll keep retrying while using ${fallbackDescriptor}.`;
          relayWarningElement.classList.remove("hidden");
          renderRelayDiagnostics(failingDiagnostics);
        }

        const hasReachable = diagnostics.some((entry) => entry.status === "ok");
        if (!hasReachable && diagnostics.length) {
          const error = new Error("No reachable relays detected");
          error.diagnostics = diagnostics;
          throw error;
        }

        statusMessageElement.classList.add("hidden");
        return { healthy, fundstrProbe };
      }

      const relayRefreshScheduler = createExponentialBackoffScheduler(
        () => refreshRelays(),
        {
          initialRetryDelayMs: 5000,
          maxRetryDelayMs: 180000,
          successDelayMs: 30000,
          onFailure: (_error, { nextDelay }) => {
            const diagnostics = getMonitoredDiagnostics();
            const failingDiagnostics = diagnostics.filter(
              (entry) => entry.status === "error",
            );
            renderRelayDiagnostics(failingDiagnostics);

            const fallbackDescriptor = computeFallbackDescriptor(RELAYS.slice(1));
            const nextRetrySeconds = Math.max(1, Math.round(nextDelay / 1000));
            const lastErrorSummary = describeLastError(failingDiagnostics);

            relayWarningElement.textContent =
              fallbackDescriptor === "no backups available"
                ? `${primaryRelayLabel} remains unreachable (${lastErrorSummary}). Retrying in ${nextRetrySeconds}s with no backups available.`
                : `${primaryRelayLabel} remains unreachable (${lastErrorSummary}). Retrying in ${nextRetrySeconds}s while monitoring ${fallbackDescriptor}.`;
            relayWarningElement.classList.remove("hidden");

            statusMessageElement.textContent =
              fallbackDescriptor === "no backups available"
                ? `Network error: could not reach ${primaryRelayLabel} and no curated backups are configured.`
                : `Network error: could not reach ${primaryRelayLabel} or backups (${fallbackDescriptor}).`;
            statusMessageElement.classList.remove("hidden");
          },
          onSuccess: () => {
            statusMessageElement.classList.add("hidden");
          },
        },
      );

      relayRefreshScheduler.start();

      window.addEventListener("beforeunload", () => {
        relayRefreshScheduler.stop();
      });

      const FEATURED_NPUBS = [
        "npub1aljmhjp5tqrw3m60ra7t3u8uqq223d6rdg9q0h76a8djd9m4hmvsmlj82m",
        "npub1sg6plzptd64u62a878hep2kev88swjh3tw00gjsfl8f237lmu63q0uf63m",
        "npub1qny3tkh0acurzla8x3zy4nhrjz5zd8l9sy9jys09umwng00manysew95gx",
        "npub1cj8znuztfqkvq89pl8hceph0svvvqk0qay6nydgk9uyq7fhpfsgsqwrz4u",
        "npub1a2cww4kn9wqte4ry70vyfwqyqvpswksna27rtxd8vty6c74era8sdcw83a",
        "npub1s05p3ha7en49dv8429tkk07nnfa9pcwczkf5x5qrdraqshxdje9sq6eyhe",
        "npub180cvv07tjdrrgpa0j7j7tmnyl2yr6yr7l8j4s3evf6u64th6gkwsyjh6w6",
        "npub1dergggklka99wwrs92yz8wdjs952h2ux2ha2ed598ngwu9w7a6fsh9xzpc",
        "npub1s5yq6wadwrxde4lhfs56gn64hwzuhnfa6r9mj476r5s4hkunzgzqrs6q7z",
        "npub1spdnfacgsd7lk0nlqkq443tkq4jx9z6c6ksvaquuewmw7d3qltpslcq6j7",
      ];

      const searchInputElement = document.getElementById("searchInput");
      const resultsListElement = document.getElementById("resultsList");
      const loaderElement = document.getElementById("loader");
      const featuredCreatorsGridElement = document.getElementById(
        "featuredCreatorsGrid",
      );
      const featuredCreatorsLoaderElement = document.getElementById(
        "featuredCreatorsLoader",
      );
      const featuredStatusMessageElement = document.getElementById(
        "featuredStatusMessage",
      );

      const nip05Regex = /^([a-zA-Z0-9_.-]+)@([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})$/;

      function debounce(func, delay) {
        let timeoutId;
        return function (...args) {
          clearTimeout(timeoutId);
          timeoutId = setTimeout(() => func.apply(this, args), delay);
        };
      }

      function fetchWithTimeout(resource, options = {}) {
        const { timeout = 8000 } = options;
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), timeout);
        const promise = fetch(resource, {
          ...options,
          signal: controller.signal,
        });
        promise.finally(() => clearTimeout(id));
        return promise;
      }

      function initializeSearchState() {
        currentSearchProfiles = new Map();
        hasInitialRender = false;
        viewProfileNotified = false;
        resultsListElement.textContent = "";
        statusMessageElement.textContent = "";
        statusMessageElement.classList.add("hidden");
        retryButtonElement.classList.add("hidden");
      }

      function getUnreachableRelaySet() {
        const diagnostics = getMonitoredDiagnostics();
        const unreachable = new Set();
        diagnostics.forEach((entry) => {
          if (entry.status === "error") {
            unreachable.add(entry.url);
          }
        });
        return unreachable;
      }

      function partitionReachableRelays(relays) {
        const unreachable = getUnreachableRelaySet();
        const uniqueRelays = Array.from(
          new Set((Array.isArray(relays) ? relays : []).filter(Boolean)),
        );
        const reachable = [];
        const skipped = [];
        uniqueRelays.forEach((relay) => {
          if (unreachable.has(relay)) {
            skipped.push(relay);
          } else {
            reachable.push(relay);
          }
        });
        return { reachable, skipped };
      }

      function reportSearchStageDuration(stage, durationMs, metadata = {}) {
        const payload = {
          stage,
          durationMs: Math.round(durationMs),
          timestamp: Date.now(),
          ...metadata,
        };

        try {
          if (
            typeof window !== "undefined" &&
            typeof window.dispatchEvent === "function" &&
            typeof CustomEvent === "function"
          ) {
            window.dispatchEvent(
              new CustomEvent("fundstr:find-creators:stage-timing", {
                detail: payload,
              }),
            );
          }
        } catch (_error) {
          /* no-op */
        }

        try {
          const telemetry =
            window.__FUNDSTR_SEARCH_TELEMETRY__ ||
            window.__FUNDSTR_TELEMETRY__;
          if (telemetry) {
            if (typeof telemetry.report === "function") {
              telemetry.report(payload);
              return;
            }
            if (typeof telemetry.emit === "function") {
              telemetry.emit("find-creators-stage", payload);
              return;
            }
            if (typeof telemetry.push === "function") {
              telemetry.push(payload);
              return;
            }
          }
        } catch (error) {
          console.debug(
            "Search stage telemetry dispatch failed",
            error,
            payload,
          );
          return;
        }

        if (typeof console !== "undefined" && typeof console.debug === "function") {
          console.debug("Search stage telemetry", payload);
        }
      }

      function createStageTimer() {
        const starts = new Map();
        const now = () =>
          typeof performance !== "undefined" && performance?.now
            ? performance.now()
            : Date.now();
        return {
          start(stage) {
            if (!stage) return;
            starts.set(stage, now());
          },
          end(stage, metadata = {}) {
            if (!stage) return;
            const start = starts.get(stage);
            if (typeof start !== "number") return;
            starts.delete(stage);
            reportSearchStageDuration(stage, now() - start, metadata);
          },
          cancel(stage) {
            if (!stage) return;
            starts.delete(stage);
          },
        };
      }

      function mergeProfilesIntoCurrent(profiles) {
        let changed = false;
        profiles.forEach((profile) => {
          if (!profile || !profile.pubkey) return;
          const existing = currentSearchProfiles.get(profile.pubkey);
          const existingCreatedAt = existing?.event?.created_at ?? 0;
          const nextCreatedAt = profile?.event?.created_at ?? 0;
          if (!existing || nextCreatedAt >= existingCreatedAt) {
            currentSearchProfiles.set(profile.pubkey, profile);
            changed = true;
          }
        });
        return changed;
      }

      function applyProfiles(profiles, { notifyView = false, targetPubkey } = {}) {
        if (!Array.isArray(profiles) || profiles.length === 0) return;
        const updated = mergeProfilesIntoCurrent(profiles);
        if (!updated && hasInitialRender) return;

        const orderedProfiles = Array.from(currentSearchProfiles.values());
        renderProfiles(orderedProfiles, resultsListElement, false);

        if (!hasInitialRender) {
          hasInitialRender = true;
          updateStatus("", true);
          loaderElement.style.display = "none";
          if (notifyView && targetPubkey && !viewProfileNotified) {
            window.parent.postMessage(
              { type: "viewProfile", pubkey: targetPubkey },
              "*",
            );
            viewProfileNotified = true;
          }
        } else if (notifyView && targetPubkey && !viewProfileNotified) {
          window.parent.postMessage(
            { type: "viewProfile", pubkey: targetPubkey },
            "*",
          );
          viewProfileNotified = true;
        }
      }

      function observeProfilesPromise(
        promise,
        signal,
        { notifyView = false, targetPubkey, sourceLabel } = {},
      ) {
        promise
          .then((profiles) => {
            if (signal.aborted) return;
            const normalized = Array.isArray(profiles) ? profiles : [];
            if (normalized.length > 0) {
              applyProfiles(normalized, { notifyView, targetPubkey });
            }
          })
          .catch((error) => {
            if (error.name === "AbortError") return;
            if (sourceLabel) {
              console.error(`${sourceLabel} profile fetch failed:`, error);
            } else {
              console.error("Profile fetch failed:", error);
            }
          });
        return promise;
      }

      function firstNonEmptyPromise(promise, signal, label) {
        return promise.then((profiles) => {
          if (signal.aborted)
            throw new DOMException("Aborted", "AbortError");
          const normalized = Array.isArray(profiles) ? profiles : [];
          if (normalized.length > 0) {
            return { profiles: normalized, label };
          }
          const error = new Error(`${label}-empty`);
          error.code = EMPTY_RESULT_CODE;
          throw error;
        });
      }

      function updateStatusIfPending(message) {
        if (!hasInitialRender) {
          updateStatus(message);
        }
      }

      async function handleSearch(query) {
        const cleanQuery = query.trim();
        lastSearchQuery = cleanQuery;

        if (currentSearchAbortController) {
          currentSearchAbortController.abort();
        }
        currentSearchAbortController = new AbortController();
        const { signal } = currentSearchAbortController;

        initializeSearchState();
        loaderElement.style.display = "block";

        if (!cleanQuery) {
          loaderElement.style.display = "none";
          return;
        }

        try {
          let pubkeyToFind = null;
          if (cleanQuery.startsWith("npub1")) {
            try {
              pubkeyToFind = nip19.decode(cleanQuery).data;
            } catch (e) {
              /* ignore invalid npub */
            }
          } else if (
            cleanQuery.length === 64 &&
            /^[0-9a-fA-F]+$/.test(cleanQuery)
          ) {
            pubkeyToFind = cleanQuery.toLowerCase();
          } else if (nip05Regex.test(cleanQuery)) {
            updateStatus("Resolving NIP-05 identifier...");
            const profile = await resolveNip05(cleanQuery, signal);
            if (profile) pubkeyToFind = profile.pubkey;
          }

          if (pubkeyToFind) {
            await findProfileByPubkey(pubkeyToFind, signal);
            return;
          }

          updateStatus(`Searching relays for "${cleanQuery}"...`);
          const filter = { kinds: [0], search: cleanQuery, limit: 25 };
          const fundstrPromise = observeProfilesPromise(
            fetchProfilesFromFundstr(filter, signal),
            signal,
            { sourceLabel: primaryRelayLabel },
          );
          const pooledPromise = observeProfilesPromise(
            fetchProfilesFromRelays(RELAYS, filter, signal),
            signal,
            { sourceLabel: "Relay pool" },
          );

          try {
            await Promise.any([
              firstNonEmptyPromise(fundstrPromise, signal, "fundstr"),
              firstNonEmptyPromise(pooledPromise, signal, "relay-pool"),
            ]);
          } catch (error) {
            if (signal.aborted) return;
            if (error.name === "AggregateError") {
              const aggregateErrors = Array.isArray(error.errors)
                ? error.errors
                : [];
              const nonEmptyErrors = aggregateErrors.filter(
                (err) => err && err.code !== EMPTY_RESULT_CODE,
              );
              if (nonEmptyErrors.length > 0) {
                throw nonEmptyErrors[0];
              }
              if (!hasInitialRender) {
                updateStatus(`No profiles found matching your search.`);
              }
            } else {
              throw error;
            }
          }
        } catch (error) {
          if (error.name !== "AbortError") {
            console.error("Search failed:", error);
            const msg =
              error.message && error.message.includes("Failed to fetch")
                ? "Network error: could not reach relays."
                : error.name === "AbortError"
                ? "Search timed out."
                : `Search failed: ${error.message}`;
            updateStatus(msg, false, true);
          }
        } finally {
          if (!signal.aborted && !hasInitialRender) {
            loaderElement.style.display = "none";
          }
        }
      }

      async function findProfileByPubkey(pubkey, signal) {
        initializeSearchState();
        loaderElement.style.display = "block";

        const filter = { kinds: [0], authors: [pubkey] };
        const watchOptions = { notifyView: true, targetPubkey: pubkey };
        const stageTimers = createStageTimer();

        updateStatus("Searching known relays for profile...");

        try {
          const primaryPartition = partitionReachableRelays(RELAYS);
          const reachableRelays = primaryPartition.reachable;
          const skippedKnownRelays = primaryPartition.skipped;
          const fundstrReachable = reachableRelays.includes(FUNDSTR_RELAY);

          const primaryPromises = [];
          if (fundstrReachable) {
            const fundstrPromise = observeProfilesPromise(
              fetchProfilesFromFundstr(filter, signal),
              signal,
              { ...watchOptions, sourceLabel: primaryRelayLabel },
            );
            primaryPromises.push(
              firstNonEmptyPromise(fundstrPromise, signal, "fundstr"),
            );
          }

          if (reachableRelays.length > 0) {
            const knownRelayPromise = observeProfilesPromise(
              fetchProfilesFromRelays(reachableRelays, filter, signal),
              signal,
              { ...watchOptions, sourceLabel: "Known relays" },
            );
            primaryPromises.push(
              firstNonEmptyPromise(
                knownRelayPromise,
                signal,
                "known-relays",
              ),
            );
          }

          stageTimers.start("primary-search");
          let primaryStageMetadata = {
            result: primaryPromises.length ? "pending" : "skipped",
            attempts: primaryPromises.length,
            reachableRelays: reachableRelays.length,
            skippedRelays: skippedKnownRelays.length,
            fundstrAttempted: fundstrReachable,
          };

          try {
            if (primaryPromises.length > 0) {
              await Promise.any(primaryPromises);
              primaryStageMetadata.result = hasInitialRender
                ? "success"
                : "empty";
            } else if (signal.aborted) {
              primaryStageMetadata.result = "aborted";
            }
          } catch (error) {
            if (error.name === "AggregateError") {
              const aggregateErrors = Array.isArray(error.errors)
                ? error.errors
                : [];
              const nonEmptyErrors = aggregateErrors.filter(
                (err) => err && err.code !== EMPTY_RESULT_CODE,
              );
              if (nonEmptyErrors.length > 0) {
                primaryStageMetadata.result = "error";
                throw nonEmptyErrors[0];
              }
              primaryStageMetadata.result = "empty";
            } else {
              primaryStageMetadata.result =
                error.name === "AbortError" ? "aborted" : "error";
              throw error;
            }
          } finally {
            stageTimers.end("primary-search", primaryStageMetadata);
          }

          if (signal.aborted || hasInitialRender) return;

          updateStatusIfPending(
            "Profile not found. Discovering user's relays...",
          );

          stageTimers.start("user-relay-discovery");
          let userRelays = [];
          let reachableUserRelays = [];
          let skippedUserRelays = [];
          let userDiscoveryMetadata = {
            result: "empty",
            discovered: 0,
            reachable: 0,
            skipped: 0,
          };

          try {
            userRelays = await findUserRelayList(pubkey, signal);
            const partitioned = partitionReachableRelays(userRelays);
            reachableUserRelays = partitioned.reachable;
            skippedUserRelays = partitioned.skipped;
            const discoveredCount = userRelays.length;
            const reachableCount = reachableUserRelays.length;
            userDiscoveryMetadata = {
              result:
                reachableCount > 0
                  ? "success"
                  : discoveredCount > 0
                  ? "skipped"
                  : "empty",
              discovered: discoveredCount,
              reachable: reachableCount,
              skipped: skippedUserRelays.length,
            };
          } catch (error) {
            userDiscoveryMetadata = {
              result: error.name === "AbortError" ? "aborted" : "error",
              discovered: userRelays.length,
              reachable: reachableUserRelays.length,
              skipped: skippedUserRelays.length,
              errorMessage: error.message,
            };
            throw error;
          } finally {
            stageTimers.end("user-relay-discovery", userDiscoveryMetadata);
          }

          if (signal.aborted || hasInitialRender) return;

          if (reachableUserRelays.length > 0) {
            updateStatusIfPending(
              `Searching ${reachableUserRelays.length} newly discovered relays...`,
            );

            stageTimers.start("user-relay-search");
            let userRelaySearchMetadata = {
              result: "empty",
              relayCount: reachableUserRelays.length,
            };

            try {
              const userRelayPromise = observeProfilesPromise(
                fetchProfilesFromRelays(reachableUserRelays, filter, signal),
                signal,
                { ...watchOptions, sourceLabel: "Discovered relays" },
              );
              const userProfiles = await userRelayPromise;
              userRelaySearchMetadata = {
                result:
                  Array.isArray(userProfiles) && userProfiles.length > 0
                    ? "success"
                    : "empty",
                relayCount: reachableUserRelays.length,
                profileCount: Array.isArray(userProfiles)
                  ? userProfiles.length
                  : 0,
              };
            } catch (error) {
              userRelaySearchMetadata = {
                result: error.name === "AbortError" ? "aborted" : "error",
                relayCount: reachableUserRelays.length,
                errorMessage: error.message,
              };
              throw error;
            } finally {
              stageTimers.end("user-relay-search", userRelaySearchMetadata);
            }
          }

          if (signal.aborted || hasInitialRender) return;

          updateStatusIfPending(
            "Checking nostr.band and Primal in parallel...",
          );

          const parallelTasks = [];
          const racePromises = [];

          const nostrBandRelayTask = (async () => {
            stageTimers.start("nostrband-relay-discovery");
            let discoveryMetadata = {
              result: "empty",
              discovered: 0,
              reachable: 0,
              skipped: 0,
            };
            let reachableIndexedRelays = [];
            try {
              const indexedRelays = await fetchRelayListFromIndexer(
                pubkey,
                signal,
              );
              const partitioned = partitionReachableRelays(indexedRelays);
              reachableIndexedRelays = partitioned.reachable;
              const discoveredCount = Array.isArray(indexedRelays)
                ? indexedRelays.length
                : 0;
              const reachableCount = reachableIndexedRelays.length;
              const skippedCount = partitioned.skipped.length;
              discoveryMetadata = {
                result:
                  reachableCount > 0
                    ? "success"
                    : discoveredCount > 0
                    ? "skipped"
                    : "empty",
                discovered: discoveredCount,
                reachable: reachableCount,
                skipped: skippedCount,
              };
            } catch (error) {
              discoveryMetadata = {
                result: error.name === "AbortError" ? "aborted" : "error",
                discovered: 0,
                reachable: 0,
                skipped: 0,
                errorMessage: error.message,
              };
              throw error;
            } finally {
              stageTimers.end(
                "nostrband-relay-discovery",
                discoveryMetadata,
              );
            }

            if (signal.aborted || reachableIndexedRelays.length === 0) {
              return [];
            }

            stageTimers.start("nostrband-relay-search");
            let relaySearchMetadata = {
              result: "empty",
              relayCount: reachableIndexedRelays.length,
            };
            try {
              const indexedRelayPromise = observeProfilesPromise(
                fetchProfilesFromRelays(
                  reachableIndexedRelays,
                  filter,
                  signal,
                ),
                signal,
                { ...watchOptions, sourceLabel: "Indexed relays" },
              );
              const profiles = await indexedRelayPromise;
              relaySearchMetadata = {
                result:
                  Array.isArray(profiles) && profiles.length > 0
                    ? "success"
                    : "empty",
                relayCount: reachableIndexedRelays.length,
                profileCount: Array.isArray(profiles) ? profiles.length : 0,
              };
              return Array.isArray(profiles) ? profiles : [];
            } catch (error) {
              relaySearchMetadata = {
                result: error.name === "AbortError" ? "aborted" : "error",
                relayCount: reachableIndexedRelays.length,
                errorMessage: error.message,
              };
              throw error;
            } finally {
              stageTimers.end("nostrband-relay-search", relaySearchMetadata);
            }
          })();
          parallelTasks.push(nostrBandRelayTask);
          racePromises.push(
            firstNonEmptyPromise(
              nostrBandRelayTask,
              signal,
              "nostr-band-relays",
            ),
          );

          const nostrBandProfileTask = (async () => {
            stageTimers.start("nostrband-profile");
            let profileMetadata = { result: "empty" };
            try {
              const indexerProfilePromise = fetchProfileFromIndexer(
                pubkey,
                signal,
              );
              observeProfilesPromise(
                indexerProfilePromise.then((profile) =>
                  profile ? [profile] : [],
                ),
                signal,
                { ...watchOptions, sourceLabel: "nostr.band profile" },
              );
              const profile = await indexerProfilePromise;
              profileMetadata = {
                result: profile ? "success" : "empty",
              };
              return profile ? [profile] : [];
            } catch (error) {
              profileMetadata = {
                result: error.name === "AbortError" ? "aborted" : "error",
                errorMessage: error.message,
              };
              throw error;
            } finally {
              stageTimers.end("nostrband-profile", profileMetadata);
            }
          })();
          parallelTasks.push(nostrBandProfileTask);
          racePromises.push(
            firstNonEmptyPromise(
              nostrBandProfileTask,
              signal,
              "nostr-band-profile",
            ),
          );

          const primalProfileTask = (async () => {
            stageTimers.start("primal-profile");
            let primalMetadata = { result: "empty" };
            try {
              const primalProfilePromise = fetchProfileFromPrimal(
                pubkey,
                signal,
              );
              observeProfilesPromise(
                primalProfilePromise.then((profile) =>
                  profile ? [profile] : [],
                ),
                signal,
                { ...watchOptions, sourceLabel: "Primal profile" },
              );
              const profile = await primalProfilePromise;
              primalMetadata = {
                result: profile ? "success" : "empty",
              };
              return profile ? [profile] : [];
            } catch (error) {
              primalMetadata = {
                result: error.name === "AbortError" ? "aborted" : "error",
                errorMessage: error.message,
              };
              throw error;
            } finally {
              stageTimers.end("primal-profile", primalMetadata);
            }
          })();
          parallelTasks.push(primalProfileTask);
          racePromises.push(
            firstNonEmptyPromise(
              primalProfileTask,
              signal,
              "primal-profile",
            ),
          );

          try {
            if (racePromises.length > 0) {
              await Promise.any(racePromises);
            }
          } catch (error) {
            if (signal.aborted) return;
            if (error.name === "AggregateError") {
              const aggregateErrors = Array.isArray(error.errors)
                ? error.errors
                : [];
              const nonEmptyErrors = aggregateErrors.filter(
                (err) => err && err.code !== EMPTY_RESULT_CODE,
              );
              if (nonEmptyErrors.length > 0) {
                throw nonEmptyErrors[0];
              }
            } else {
              throw error;
            }
          } finally {
            await Promise.allSettled(parallelTasks);
          }

          if (!hasInitialRender && !signal.aborted) {
            updateStatus(
              "Profile could not be found after exhaustive search on known relays, discovered relays, and multiple public indexers.",
            );
          }
        } catch (error) {
          if (error.name === "AbortError") return;
          console.error("Search failed:", error);
          if (!hasInitialRender) {
            const msg =
              error.message && error.message.includes("Failed to fetch")
                ? "Network error: could not reach relays."
                : error.name === "AbortError"
                ? "Search timed out."
                : `Search failed: ${error.message}`;
            updateStatus(msg, false, true);
          }
        } finally {
          if (!signal.aborted && !hasInitialRender) {
            loaderElement.style.display = "none";
          }
        }
      }

      async function fetchProfileFromIndexer(pubkey, signal) {
        try {
          const response = await fetchWithTimeout(
            `https://api.nostr.band/v0/profile?pubkey=${pubkey}`,
            { signal },
          );
          if (!response.ok) return null;
          const data = await response.json();
          if (data && data.profile) {
            const content = JSON.parse(data.profile.content);
            return {
              pubkey: data.profile.pubkey,
              name:
                content.name || content.display_name || content.username || "",
              nip05: content.nip05 || "",
              picture: content.picture || "",
              about: content.about || "",
              lud16: content.lud16 || "",
              event: data.profile,
            };
          }
          return null;
        } catch (error) {
          if (error.name === "AbortError") throw error;
          console.error("nostr.band API error:", error);
          return null;
        }
      }

      async function fetchProfileFromPrimal(pubkey, signal) {
        try {
          const primalUrl = `https://primal-cache.snort.social/api/v1/eose/user/profile/${pubkey}`;
          const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(
            primalUrl,
          )}`;
          const response = await fetchWithTimeout(proxyUrl, { signal });
          if (!response.ok) return null;
          const data = await response.json();
          if (data && data[0] && data[0].content) {
            const content = JSON.parse(data[0].content);
            return {
              pubkey: data[0].pubkey,
              name:
                content.name || content.display_name || content.username || "",
              nip05: content.nip05 || "",
              picture: content.picture || "",
              about: content.about || "",
              lud16: content.lud16 || "",
              event: data[0],
            };
          }
          return null;
        } catch (error) {
          if (error.name === "AbortError") throw error;
          console.error("Primal API error:", error);
          return null;
        }
      }

      async function fetchRelayListFromIndexer(pubkey, signal) {
        try {
          const response = await fetchWithTimeout(
            `https://api.nostr.band/v0/relays/for_pubkey/${pubkey}`,
            { signal },
          );
          if (!response.ok) return [];
          const data = await response.json();
          if (data && Array.isArray(data.relays)) {
            return data.relays.map((r) => r.relay);
          }
          return [];
        } catch (error) {
          if (error.name === "AbortError") throw error;
          console.error("nostr.band relay list fetch error:", error);
          return [];
        }
      }

      async function findUserRelayList(pubkey, signal) {
        const filter = { kinds: [10002], authors: [pubkey], limit: 1 };
        const { reachable: reachableRelays } = partitionReachableRelays(RELAYS);
        if (reachableRelays.length === 0) {
          return [];
        }
        const events = await fetchEventsFromRelays(
          reachableRelays,
          filter,
          signal,
          4000,
        );
        if (events.length > 0) {
          return events[0].tags
            .filter((tag) => tag[0] === "r" && tag[1])
            .map((tag) => tag[1]);
        }
        return [];
      }

      async function fetchProfilesFromRelays(
        relays,
        filter,
        signal,
        options = {},
      ) {
        const timeoutMs = options?.timeout;
        const retries = options?.retries ?? 1;
        const retryDelay = options?.retryDelay;
        const events = await fetchEventsFromRelays(
          relays,
          filter,
          signal,
          timeoutMs,
          retries,
          retryDelay,
        );
        const profileMap = new Map();
        events.forEach((event) => {
          if (event.kind === 0) {
            try {
              const profileData = JSON.parse(event.content);
              const existing = profileMap.get(event.pubkey);
              if (!existing || event.created_at > existing.event.created_at) {
                profileMap.set(event.pubkey, {
                  pubkey: event.pubkey,
                  name:
                    profileData.name ||
                    profileData.display_name ||
                    profileData.username ||
                    "",
                  nip05: profileData.nip05 || "",
                  picture: profileData.picture || "",
                  about: profileData.about || "",
                  lud16: profileData.lud16 || "",
                  event: event,
                });
              }
            } catch (e) {
              console.error(
                "Failed to parse profile event content",
                e,
                event.content,
              );
            }
          }
        });
        return Array.from(profileMap.values());
      }

      function fetchProfilesFromFundstr(filter, signal) {
        return fetchProfilesFromRelays([FUNDSTR_RELAY], filter, signal, {
          timeout: 1000,
          retries: 2,
          retryDelay: 350,
        });
      }

      async function fetchEventsFromRelays(
        relays,
        filter,
        signal,
        timeout = 7000,
        retries = 1,
        retryDelay = 1000,
      ) {
        const debounceDelay = 180;
        const uniqueRelays = [...new Set(relays)].filter(Boolean);

        async function attempt() {
          return await new Promise((resolve, reject) => {
            if (signal.aborted)
              return reject(new DOMException("Aborted", "AbortError"));

            const events = [];
            const relayStates = new Map(
              uniqueRelays.map((relay) => [relay, { hasEvent: false, hasEose: false }]),
            );
            let resolved = false;
            let debounceId = null;
            let cleanupCalled = false;

            const sub = pool.sub(uniqueRelays, [filter]);

            const resolveRelayUrl = (relayRef) => {
              if (!relayRef) return undefined;
              if (typeof relayRef === "string") return relayRef;
              if (typeof relayRef === "object" && typeof relayRef.url === "string")
                return relayRef.url;
              return undefined;
            };

            let timeoutId = null;

            const cleanup = () => {
              if (cleanupCalled) return;
              cleanupCalled = true;
              try {
                sub.unsub();
              } catch (e) {}
              signal.removeEventListener("abort", onAbort);
              if (timeoutId !== null) {
                clearTimeout(timeoutId);
              }
              if (debounceId) {
                clearTimeout(debounceId);
                debounceId = null;
              }
            };

            const onAbort = () => {
              cleanup();
              reject(new DOMException("Aborted", "AbortError"));
            };
            signal.addEventListener("abort", onAbort);

            const finish = () => {
              if (resolved) return;
              resolved = true;
              cleanup();
              resolve(events);
            };

            const scheduleResolveIfComplete = () => {
              if (resolved) return;
              if (
                relayStates.size === 0 ||
                Array.from(relayStates.values()).every(
                  (state) => state.hasEvent || state.hasEose,
                )
              ) {
                if (debounceId) clearTimeout(debounceId);
                debounceId = setTimeout(finish, debounceDelay);
              }
            };

            const markRelay = (relayRef, field) => {
              if (relayStates.size === 0) {
                scheduleResolveIfComplete();
                return;
              }

              const relayUrl = resolveRelayUrl(relayRef);
              if (relayUrl && relayStates.has(relayUrl)) {
                const state = relayStates.get(relayUrl);
                if (!state[field]) {
                  state[field] = true;
                  scheduleResolveIfComplete();
                }
                return;
              }

              if (!relayUrl && relayStates.size === 1) {
                const onlyRelay = relayStates.keys().next().value;
                if (onlyRelay) {
                  const state = relayStates.get(onlyRelay);
                  if (!state[field]) {
                    state[field] = true;
                    scheduleResolveIfComplete();
                  }
                }
              }
            };

            timeoutId = setTimeout(finish, timeout);

            sub.on("event", (event, relayRef) => {
              events.push(event);
              markRelay(relayRef, "hasEvent");
            });

            sub.on("eose", (relayRef) => {
              markRelay(relayRef, "hasEose");
            });

            scheduleResolveIfComplete();
          });
        }

        for (let attemptNum = 0; attemptNum <= retries; attemptNum++) {
          try {
            const events = await attempt();
            if (events.length > 0 || attemptNum === retries) {
              return events;
            }
          } catch (err) {
            if (err.name === "AbortError" || attemptNum === retries) throw err;
          }
          const effectiveDelay = retryDelay ?? 1000;
          if (effectiveDelay > 0) {
            await new Promise((res) => setTimeout(res, effectiveDelay));
          }
        }
        return [];
      }

      async function resolveNip05(nip05, signal) {
        const match = nip05.match(nip05Regex);
        if (!match) return null;
        const [, localPart, domain] = match;
        try {
          const url = `https://${domain}/.well-known/nostr.json?name=${encodeURIComponent(
            localPart,
          )}`;
          const response = await fetchWithTimeout(url, { signal });
          if (!response.ok) return null;
          const data = await response.json();
          if (data.names && data.names[localPart]) {
            return { pubkey: data.names[localPart] };
          }
        } catch (error) {
          if (error.name !== "AbortError")
            console.error("NIP-05 resolution failed:", error);
        }
        return null;
      }

      function updateStatus(message, hide = false, showRetry = false) {
        if (hide) {
          statusMessageElement.classList.add("hidden");
        } else {
          statusMessageElement.textContent = message;
          statusMessageElement.classList.remove("hidden");
        }
        if (showRetry) {
          retryButtonElement.classList.remove("hidden");
        } else {
          retryButtonElement.classList.add("hidden");
        }
      }

      function renderProfiles(profiles, targetElement, isFeatured) {
        targetElement.textContent = "";
        if (profiles.length === 0) return;

        profiles.sort((a, b) => (a.name || "").localeCompare(b.name || ""));

        profiles.forEach((profile) => {
          const cardElement = document.createElement(isFeatured ? "div" : "li");
          cardElement.className = `${
            isFeatured ? "creator-card" : "result-item"
          } group`;
          const profileHeaderDiv = document.createElement("div");
          profileHeaderDiv.className = "profile-header";
          const avatarImg = document.createElement("img");
          avatarImg.className = "avatar";
          const avatarLetter = (profile.name || "N")[0]?.toUpperCase();
          avatarImg.src = isTrustedUrl(profile.picture)
            ? profile.picture
            : `https://placehold.co/50x50/A0AEC0/FFFFFF?text=${avatarLetter}`;
          avatarImg.alt = profile.name || "Nostr User";
          avatarImg.onerror = function () {
            this.src = `https://placehold.co/50x50/A0AEC0/FFFFFF?text=${avatarLetter}`;
          };
          const infoDiv = document.createElement("div");
          infoDiv.className = "info";
          const nameElement = document.createElement("h3");
          nameElement.textContent =
            profile.name ||
            (profile.nip05 ? profile.nip05.split("@")[0] : "Unnamed User");
          const npub = nip19.npubEncode(profile.pubkey);
          const npubShort = `${npub.substring(0, 10)}...${npub.substring(
            npub.length - 5,
          )}`;
          const npubElement = document.createElement("p");
          const npubStrong = document.createElement("strong");
          npubStrong.textContent = "Npub:";
          npubElement.appendChild(npubStrong);
          npubElement.append(` ${npubShort}`);
          npubElement.title = npub;
          const copyNpubButton = document.createElement("button");
          copyNpubButton.textContent = "Copy";
          copyNpubButton.className = "copy-button";
          copyNpubButton.onclick = (e) => {
            e.stopPropagation();
            copyToClipboard(npub, copyNpubButton);
          };
          npubElement.appendChild(copyNpubButton);
          infoDiv.appendChild(nameElement);
          infoDiv.appendChild(npubElement);
          if (profile.nip05) {
            const nip05Element = document.createElement("p");
            const nip05Strong = document.createElement("strong");
            nip05Strong.textContent = "NIP-05:";
            nip05Element.appendChild(nip05Strong);
            const nip05Span = document.createElement("span");
            nip05Span.className = "nip05";
            nip05Span.textContent = profile.nip05;
            nip05Element.append(" ");
            nip05Element.appendChild(nip05Span);
            infoDiv.appendChild(nip05Element);
          }
          if (profile.about) {
            const aboutElement = document.createElement("p");
            const aboutText =
              profile.about.length > (isFeatured ? 80 : 150)
                ? profile.about.substring(0, isFeatured ? 80 : 150) + "..."
                : profile.about;
            const aboutEm = document.createElement("em");
            aboutEm.textContent = aboutText;
            aboutElement.appendChild(aboutEm);
            aboutElement.title = profile.about;
            infoDiv.appendChild(aboutElement);
          }
          if (profile.lud16) {
            const lud16Element = document.createElement("p");
            const lud16Strong = document.createElement("strong");
            lud16Strong.textContent = "LN:";
            lud16Element.appendChild(lud16Strong);
            lud16Element.append(` ${profile.lud16}`);
            infoDiv.appendChild(lud16Element);
          }
          profileHeaderDiv.appendChild(avatarImg);
          profileHeaderDiv.appendChild(infoDiv);
          cardElement.appendChild(profileHeaderDiv);
          const actionsContainer = document.createElement("div");
          actionsContainer.className = "creator-actions";
          const viewButton = document.createElement("button");
          viewButton.className = "action-button view-button";
          viewButton.textContent = "View Subscription Tiers";
          viewButton.onclick = (e) => {
            e.stopPropagation();
            window.parent.postMessage(
              { type: "viewProfile", pubkey: profile.pubkey },
              "*",
            );
          };
          const messageButton = document.createElement("button");
          messageButton.className = "action-button message-button";
          messageButton.textContent = "Message";
          messageButton.onclick = (e) => {
            e.stopPropagation();
            window.parent.postMessage(
              {
                type: "startChat",
                pubkey: profile.pubkey,
              },
              "*",
            );
          };
          const donateButton = document.createElement("button");
          donateButton.className = "action-button donate-button";
          donateButton.textContent = "Donate";
          donateButton.onclick = (e) => {
            e.stopPropagation();
            window.parent.postMessage(
              { type: "donate", pubkey: profile.pubkey },
              "*",
            );
          };
          actionsContainer.appendChild(viewButton);
          actionsContainer.appendChild(messageButton);
          actionsContainer.appendChild(donateButton);
          cardElement.appendChild(actionsContainer);
          targetElement.appendChild(cardElement);
        });
      }

      function escapeHtml(unsafe) {
        if (unsafe === null || unsafe === undefined) return "";
        return unsafe
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }

      function isTrustedUrl(url) {
        try {
          const parsed = new URL(url, window.location.origin);
          return parsed.protocol === "http:" || parsed.protocol === "https:";
        } catch (e) {
          return false;
        }
      }

      function copyToClipboard(text, buttonElement) {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        try {
          document.execCommand("copy");
          if (buttonElement) {
            const originalText = buttonElement.textContent;
            buttonElement.textContent = "Copied!";
            setTimeout(() => {
              buttonElement.textContent = originalText;
            }, 2000);
          }
        } catch (err) {
          console.error("Failed to copy text: ", err);
        }
        document.body.removeChild(textArea);
      }

      async function init() {
        document.body.classList.toggle(
          "dark",
          window.matchMedia("(prefers-color-scheme: dark)").matches,
        );
        featuredStatusMessageElement.textContent = "Loading featured creators...";
        featuredStatusMessageElement.classList.remove("hidden");
        const featuredPubkeysHex = FEATURED_NPUBS.map((npub) => {
          try {
            return nip19.decode(npub).data;
          } catch (e) {
            return null;
          }
        }).filter((hex) => hex !== null);

        const CACHE_KEY = "featured.creators:v1";
        const CACHE_TTL = 24 * 60 * 60 * 1000; // 24h
        let profiles = null;

        try {
          const cached = localStorage.getItem(CACHE_KEY);
          if (cached) {
            const parsed = JSON.parse(cached);
            if (
              parsed.timestamp &&
              Array.isArray(parsed.profiles) &&
              Date.now() - parsed.timestamp < CACHE_TTL
            ) {
              profiles = parsed.profiles;
            }
          }
        } catch (e) {}

        if (!profiles) {
          try {
            featuredCreatorsLoaderElement.style.display = "block";
            const res = await fetch("featured-creators.json");
            if (res.ok) {
              profiles = await res.json();
              localStorage.setItem(
                CACHE_KEY,
                JSON.stringify({ timestamp: Date.now(), profiles }),
              );
            }
          } catch (e) {}
        }

        featuredCreatorsLoaderElement.style.display = "none";

        if (profiles && profiles.length > 0) {
          renderProfiles(profiles, featuredCreatorsGridElement, true);
          featuredStatusMessageElement.classList.add("hidden");
        } else {
          featuredStatusMessageElement.textContent =
            "Could not load featured creators.";
          featuredStatusMessageElement.classList.remove("hidden");
        }

        // refresh profiles from relays in background
        if (featuredPubkeysHex.length > 0) {
          (async () => {
            try {
              const refreshed = await fetchProfilesFromRelays(
                RELAYS,
                { kinds: [0], authors: featuredPubkeysHex },
                new AbortController().signal,
              );
              if (refreshed.length > 0) {
                renderProfiles(refreshed, featuredCreatorsGridElement, true);
                localStorage.setItem(
                  CACHE_KEY,
                  JSON.stringify({ timestamp: Date.now(), profiles: refreshed }),
                );
              }
            } catch (e) {
            }
          })();
        }

        window.addEventListener("message", (ev) => {
          if (ev.data?.type === "prefillSearch" && ev.data.npub) {
            searchInputElement.value = ev.data.npub;
            handleSearch(ev.data.npub);
          } else if (ev.data?.type === "set-theme") {
            document.body.classList.toggle("dark", !!ev.data.dark);
          }
        });

        const debouncedSearchHandler = debounce(handleSearch, 500);
        searchInputElement.addEventListener("input", (event) => {
          debouncedSearchHandler(event.target.value);
        });

        retryButtonElement.addEventListener("click", () => {
          if (lastSearchQuery) {
            handleSearch(lastSearchQuery);
          }
        });

        window.addEventListener("beforeunload", () => {
          if (currentSearchAbortController) {
            currentSearchAbortController.abort();
          }
          pool.close([...RELAYS]);
        });
      }

      const stylesheet = document.querySelector(
        'link[rel="stylesheet"][href="find-creators.css"]',
      );
      function waitForStyles(cb) {
        if (!stylesheet || stylesheet.sheet) {
          cb();
        } else {
          stylesheet.addEventListener("load", cb, { once: true });
        }
      }
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", () => waitForStyles(init));
      } else {
        waitForStyles(init);
      }
    </script>
  </body>
</html>
